<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Globe with Compass - Globe.gl</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }
        #globe-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="globe-container"></div>

    <!-- Include Globe.gl and Three.js from CDN -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/globe.gl"></script>

    <script>
        // Create the Globe instance
        const globe = Globe()
            .globeImageUrl('//unpkg.com/three-globe/example/img/earth-blue-marble.jpg')
            .backgroundImageUrl('//unpkg.com/three-globe/example/img/night-sky.png')
            .showAtmosphere(true)
            .atmosphereColor('lightblue')
            .atmosphereAltitude(0.25)
            .width(window.innerWidth)
            .height(window.innerHeight)
            (document.getElementById('globe-container'));

        // Set up camera and globe position
        const scene = globe.scene();
        const camera = globe.camera();

        let userLat = 0;
        let userLon = 0;
        let userHeading = 0;

        // Function to update the user's position on the globe
        function updateGlobePosition(lat, lon) {
            userLat = lat;
            userLon = lon;

            // Center the globe on the user's location
            globe.pointOfView({ lat: userLat, lng: userLon, altitude: 2.5 }, 500); // Zoom out a bit
        }

        // Function to calculate the destination point along the great circle
        function calculateGreatCirclePoint(lat, lon, heading, distance) {
            const R = 6371e3; // Earth radius in meters
            const angularDistance = distance / R;
            const headingRad = THREE.MathUtils.degToRad(heading);

            const latRad = THREE.MathUtils.degToRad(lat);
            const lonRad = THREE.MathUtils.degToRad(lon);

            const newLatRad = Math.asin(Math.sin(latRad) * Math.cos(angularDistance) +
                Math.cos(latRad) * Math.sin(angularDistance) * Math.cos(headingRad));
            const newLonRad = lonRad + Math.atan2(
                Math.sin(headingRad) * Math.sin(angularDistance) * Math.cos(latRad),
                Math.cos(angularDistance) - Math.sin(latRad) * Math.sin(newLatRad)
            );

            return {
                lat: THREE.MathUtils.radToDeg(newLatRad),
                lon: THREE.MathUtils.radToDeg(newLonRad)
            };
        }

        // Function to update the line direction
        function updateDirectionLine(heading) {
            userHeading = heading;

            // Calculate the point 10,000 meters ahead in the direction the user is facing
            const destination = calculateGreatCirclePoint(userLat, userLon, userHeading, 10000);
            
            // Draw or update the direction line
            globe.pathsData([{
                startLat: userLat,
                startLng: userLon,
                endLat: destination.lat,
                endLng: destination.lon
            }]);
        }

        // Function to rotate the globe based on the heading
        function rotateGlobeWithHeading(heading) {
            const rotationY = THREE.MathUtils.degToRad(-heading); // Rotate the globe by heading

            // Update globe rotation
            globe.controls().autoRotate = false;  // Disable auto-rotation
            globe.controls().enableDamping = true;
            globe.controls().update();

            globe.controls().rotateLeft(rotationY);
        }

        // Geolocation to get the user's position and center the globe
        if (navigator.geolocation) {
            navigator.geolocation.watchPosition(function(position) {
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                updateGlobePosition(lat, lon);
            });
        } else {
            alert("Geolocation is not supported by this browser.");
        }

        // Device orientation to get the heading and update the direction
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', function(event) {
                const alpha = event.alpha;  // Compass heading
                if (alpha !== null) {
                    rotateGlobeWithHeading(alpha);  // Rotate the globe with heading
                    updateDirectionLine(alpha);     // Draw the line in the direction faced
                }
            });
        } else {
            alert("Device orientation not supported.");
        }

        // Handle window resizing
        window.addEventListener('resize', () => {
            globe.width(window.innerWidth).height(window.innerHeight);
        });
    </script>
</body>
</html>
